use crate::trvz::locus::{self, Locus};
use crate::utils::Result;
use itertools::Itertools;
use rust_htslib::bam::{self, record::Aux, Read as BamRead};
use rust_htslib::bcf::{self, record::GenotypeAllele::UnphasedMissing, Read as BcfRead, Record};
use rust_htslib::faidx;
use std::collections::HashSet;
use std::io::{BufRead, BufReader, Read as ioRead};
use std::path::PathBuf;
use std::str;

use super::read::{Beta, Betas, Read};

#[derive(Debug)]
pub struct Span {
    pub index: usize,
    pub start: usize,
    pub end: usize,
}

pub fn get_alleles(bcf_path: &PathBuf, locus: &Locus) -> Result<Vec<String>> {
    let mut bcf = bcf::Reader::from_path(bcf_path).unwrap();
    for record in bcf.records() {
        let record = record.map_err(|e| e.to_string())?;

        let tr_id = record.info(b"TRID").string().unwrap().unwrap();
        let tr_id = tr_id
            .iter()
            .map(|elem| str::from_utf8(elem).unwrap())
            .join(",");

        if tr_id != locus.id {
            continue;
        }

        let gt = record.genotypes().unwrap().get(0);
        if gt[0] == UnphasedMissing {
            return Err(format!("Missing genotype for TRID={}", tr_id));
        }

        let alleles = get_allele_seqs(locus, &record);
        return Ok(alleles);
    }
    Err(format!("TRID={} missing", &locus.id))
}

pub fn get_locus(
    catalog_reader: BufReader<Box<dyn ioRead>>,
    genome_reader: faidx::Reader,
    tr_id: &str,
    flank_len: usize,
) -> Result<Locus> {
    let query = format!("ID={};", tr_id);
    for line in catalog_reader.lines() {
        let line = line.unwrap();
        if line.contains(&query) {
            return locus::decode(flank_len, &genome_reader, &line);
        }
    }
    Err(format!("Unable to find locus {}", tr_id))
}

pub fn get_reads(
    bam_path: &PathBuf,
    locus: &Locus,
    max_allele_reads: Option<usize>,
) -> Result<Vec<Read>> {
    let mut reads = bam::IndexedReader::from_path(bam_path).unwrap();
    // This assumes that TRGT outputs flanks shorter than 1Kbps in length. We may want
    // to implement a more flexible mechanism for handling flank lengths here and elsewhere.
    let search_radius = 1000;
    let search_start = std::cmp::max(0, locus.region.start as i64 - search_radius as i64) as u32;
    let search_end = locus.region.end + search_radius;
    let extraction_region = (locus.region.contig.as_str(), search_start, search_end);
    reads.fetch(extraction_region).unwrap();

    let mut seqs = Vec::new();
    for read in reads.records() {
        let read = read.unwrap();
        let seq = str::from_utf8(&read.seq().as_bytes()).unwrap().to_string();

        let trid = match read.aux(b"TR") {
            Ok(Aux::String(value)) => value.to_string(),
            Ok(_) | Err(_) => {
                return Err(format!(
                    "Missing or malformed TR tag in read {}. Was this BAM file generated by the latest version of TRGT?",
                    std::str::from_utf8(read.qname()).unwrap()
                ));
            }
        };

        if trid != locus.id {
            continue;
        }

        let meth = parse_meth(&read, &seq)?;

        let allele = match read.aux(b"AL") {
            Ok(Aux::I32(value)) => value,
            Ok(_) => {
                return Err(format!(
                    "malformed AL tag in read {:?}.",
                    String::from_utf8(read.qname().to_vec()).unwrap()
                ))
            }
            Err(_) => {
                return Err(format!(
                    "Malformed read. Expected AL tag not found: {:?}",
                    String::from_utf8(read.qname().to_vec()).unwrap()
                ))
            }
        };

        let (left_flank, right_flank) = match read.aux(b"FL") {
            Ok(Aux::ArrayU32(value)) => {
                if value.len() != 2 {
                    return Err(format!(
                        "Malformed FL tag in read {:?}. Expected 2 values, found {}",
                        String::from_utf8(read.qname().to_vec()).unwrap(),
                        value.len()
                    ));
                }
                let vals = value.iter().collect::<Vec<u32>>();
                (vals[0] as usize, vals[1] as usize)
            }
            Ok(_) => {
                return Err(format!(
                    "Malformed FL tag in read {:?}.",
                    String::from_utf8(read.qname().to_vec()).unwrap()
                ))
            }
            Err(_) => {
                return Err(format!(
                    "Malformed read. Expected FL tag not found: {:?}",
                    String::from_utf8(read.qname().to_vec()).unwrap()
                ))
            }
        };

        seqs.push(Read {
            seq,
            left_flank,
            right_flank,
            allele,
            betas: meth,
        });
    }
    let seqs = if let Some(max_reads) = max_allele_reads {
        let unique_alleles: Vec<i32> = seqs
            .iter()
            .map(|x| x.allele)
            .collect::<HashSet<i32>>()
            .into_iter()
            .collect();
        unique_alleles
            .into_iter()
            .map(|allele| {
                let num_allele_reads = seqs.iter().filter(|x| x.allele == allele).count();

                // GS: this only works if spanning.bam is sorted by TR length
                let step = std::cmp::max(1_usize, num_allele_reads / max_reads);
                seqs.clone()
                    .into_iter()
                    .filter(|seq| seq.allele == allele)
                    .step_by(step)
                    .take(max_reads)
                    .collect()
            })
            .concat()
    } else {
        seqs
    };

    if seqs.is_empty() {
        return Err(format!("No reads found for TRID={}", locus.id));
    }

    Ok(seqs)
}

fn get_allele_seqs(locus: &Locus, record: &Record) -> Vec<String> {
    let lf = &locus.left_flank;
    let rf = &locus.right_flank;
    let mut alleles = Vec::new();
    let genotype = record.genotypes().unwrap().get(0);
    for allele in genotype.iter() {
        let allele_index = allele.index().unwrap() as usize;
        // Remove the padding base
        let allele_seq = record.alleles()[allele_index]
            .iter()
            .skip(1)
            .copied()
            .collect_vec();
        let allele_seq = str::from_utf8(&allele_seq).unwrap();
        alleles.push(lf.clone() + allele_seq + &rf.clone());
    }
    alleles
}

fn parse_meth(read: &bam::Record, seq: &str) -> Result<Betas> {
    let values = match read.aux(b"MC") {
        Ok(Aux::ArrayU8(value)) => {
            if !value.is_empty() {
                value.iter().collect::<Vec<u8>>()
            } else {
                return Ok(Vec::new());
            }
        }
        Ok(_) => {
            let read_name = String::from_utf8(read.qname().to_vec()).unwrap();
            return Err(format!("Bad MC tag in read {read_name}"));
        }
        Err(_) => return Ok(Vec::new()),
    };

    let mut betas = Vec::new();
    let mut cpg_count = 0;
    for pos in 0..seq.len() {
        let is_cpg = pos + 1 < seq.len() && &seq[pos..pos + 2] == "CG";
        if is_cpg {
            if cpg_count == values.len() {
                let read_name = String::from_utf8(read.qname().to_vec()).unwrap();
                return Err(format!("Bad MC tag in read {read_name}"));
            }
            let level = values[cpg_count] as f64 / 255.0;
            let beta = Beta { pos, value: level };
            betas.push(beta);
            cpg_count += 1;
        }
    }

    let all_cpgs_present = cpg_count == values.len();
    let last_cpg_split =
        seq.bytes().last().unwrap_or(b'X') == b'C' && cpg_count + 1 == values.len();

    if !(all_cpgs_present || last_cpg_split) {
        let read_name = String::from_utf8(read.qname().to_vec()).unwrap();
        return Err(format!("Bad MC tag in read {read_name}"));
    }

    Ok(betas)
}
