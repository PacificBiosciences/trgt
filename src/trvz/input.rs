use crate::hmm::{build_hmm, get_events, Hmm, HmmEvent};
use crate::trvz::{
    locus::{self, Allele, BaseLabel, Locus},
    read::Read,
    struc::RegionLabel,
};
use crate::utils::Result;
use itertools::Itertools;
use rust_htslib::{
    bam::{self, record::Aux, Read as BamRead},
    bcf::{self, record::GenotypeAllele::UnphasedMissing, Read as BcfRead, Record},
    faidx,
};
use std::{
    io::{BufRead, BufReader, Read as ioRead},
    path::PathBuf,
    str,
};

type RegionLabels = Vec<RegionLabel>;

#[derive(Debug)]
pub struct Span {
    pub index: usize,
    pub start: usize,
    pub end: usize,
}

pub fn get_genotype(bcf_path: &PathBuf, locus: &Locus) -> Result<Vec<Allele>> {
    let mut bcf = bcf::Reader::from_path(bcf_path).unwrap();
    for record in bcf.records() {
        let record = record.unwrap();

        let tr_id = record.info(b"TRID").string().unwrap().unwrap();
        let tr_id = str::from_utf8(tr_id.to_vec()[0]).unwrap();

        if tr_id != locus.id {
            continue;
        }

        let gt = record.genotypes().unwrap().get(0);
        if gt[0] == UnphasedMissing {
            return Err(format!("Missing genotype for TRID={}", tr_id));
        }

        let allele_seqs = get_allele_seqs(locus, &record);
        let region_labels_by_allele = get_region_labels(locus, &allele_seqs, &record);
        let flank_labels_by_allele = get_flank_labels(locus, &region_labels_by_allele);
        let base_labels_by_allele = label_with_hmm(locus, &allele_seqs);

        let mut genotype = Vec::new();
        for (index, seq) in allele_seqs.into_iter().enumerate() {
            genotype.push(Allele {
                seq,
                region_labels: region_labels_by_allele[index].clone(),
                flank_labels: flank_labels_by_allele[index].clone(),
                base_labels: base_labels_by_allele[index].clone(),
            });
        }

        return Ok(genotype);
    }
    Err(format!("TRID={} missing", &locus.id))
}

pub fn get_locus(
    catalog_reader: BufReader<Box<dyn ioRead>>,
    genome_reader: faidx::Reader,
    tr_id: &str,
    flank_len: usize,
) -> Result<Locus> {
    let query = format!("ID={};", tr_id);
    for line in catalog_reader.lines() {
        let line = line.unwrap();
        if line.contains(&query) {
            return locus::decode(flank_len, &genome_reader, &line);
        }
    }
    Err(format!("Unable to find locus {}", tr_id))
}

pub fn get_reads(bam_path: &PathBuf, locus: &Locus) -> Result<Vec<Read>> {
    let mut reads = bam::IndexedReader::from_path(bam_path).unwrap();
    // This assumes that TRGT outputs flanks shorter than 1Kbps in length. We may want
    // to implement a more flexible mechanism for handling flank lengths here and elsewhere.
    let search_radius = 1000;
    let search_start = std::cmp::max(0, locus.region.start as i64 - search_radius as i64) as u32;
    let search_end = locus.region.end + search_radius;
    let extraction_region = (locus.region.contig.as_str(), search_start, search_end);
    reads.fetch(extraction_region).unwrap();

    let mut seqs = Vec::new();
    for read in reads.records() {
        let read = read.unwrap();
        let seq = str::from_utf8(&read.seq().as_bytes()).unwrap().to_string();

        let trid = match read.aux(b"TR") {
            Ok(Aux::String(value)) => value.to_string(),
            Ok(_) | Err(_) => {
                return Err(format!(
                    "Missing or malformed TR tag in read {}. Was this BAM file generated by the latest version of TRGT?",
                    std::str::from_utf8(read.qname()).unwrap()
                ));
            }
        };

        if trid != locus.id {
            continue;
        }

        let meth = match read.aux(b"MC") {
            Ok(Aux::ArrayU8(value)) => {
                if !value.is_empty() {
                    Some(value.iter().collect::<Vec<u8>>())
                } else {
                    None
                }
            }
            Ok(_) => {
                return Err(format!(
                    "malformed MC tag in read {:?}.",
                    String::from_utf8(read.qname().to_vec()).unwrap()
                ))
            }
            Err(_) => None,
        };

        let allele = match read.aux(b"AL") {
            Ok(Aux::I32(value)) => value,
            Ok(_) => {
                return Err(format!(
                    "malformed AL tag in read {:?}.",
                    String::from_utf8(read.qname().to_vec()).unwrap()
                ))
            }
            Err(_) => {
                return Err(format!(
                    "malformatted read. Expected AL tag not found: {:?}",
                    String::from_utf8(read.qname().to_vec()).unwrap()
                ))
            }
        };

        let (left_flank, right_flank) = match read.aux(b"FL") {
            Ok(Aux::ArrayU32(value)) => {
                if value.len() != 2 {
                    return Err(format!(
                        "Malformed FL tag in read {:?}. Expected 2 values, found {}",
                        String::from_utf8(read.qname().to_vec()).unwrap(),
                        value.len()
                    ));
                }
                let vals = value.iter().collect::<Vec<u32>>();
                (vals[0] as usize, vals[1] as usize)
            }
            Ok(_) => {
                return Err(format!(
                    "malformatted FL tag in read {:?}.",
                    String::from_utf8(read.qname().to_vec()).unwrap()
                ))
            }
            Err(_) => {
                return Err(format!(
                    "malformatted read. Expected FL tag not found: {:?}",
                    String::from_utf8(read.qname().to_vec()).unwrap()
                ))
            }
        };

        seqs.push(Read {
            seq,
            left_flank,
            right_flank,
            allele,
            meth,
        });
    }

    Ok(seqs)
}

fn get_allele_seqs(locus: &Locus, record: &Record) -> Vec<String> {
    let lf = &locus.left_flank;
    let rf = &locus.right_flank;
    let mut alleles = Vec::new();
    let genotype = record.genotypes().unwrap().get(0);
    for allele in genotype.iter() {
        let allele_index = allele.index().unwrap() as usize;
        // Remove the padding base
        let allele_seq = record.alleles()[allele_index]
            .iter()
            .skip(1)
            .copied()
            .collect_vec();
        let allele_seq = str::from_utf8(&allele_seq).unwrap();
        alleles.push(lf.clone() + allele_seq + &rf.clone());
    }
    alleles
}

fn get_region_labels(locus: &Locus, alleles: &[String], record: &Record) -> Vec<RegionLabels> {
    let lf_len = locus.left_flank.len();
    let rf_len = locus.right_flank.len();

    let mut labels_by_hap = Vec::new();
    let ms_field = record.format(b"MS").string().unwrap();
    let ms_field = str::from_utf8(ms_field.to_vec()[0]).unwrap();
    for (allele_index, spans) in ms_field.split(',').enumerate() {
        let allele_len = alleles[allele_index].len();
        if spans == "." {
            let tr_start = lf_len;
            let tr_end = allele_len - rf_len;

            labels_by_hap.push(vec![
                RegionLabel::Flank(0, tr_start),
                RegionLabel::Other(tr_start, tr_end),
                RegionLabel::Flank(tr_end, allele_len),
            ]);
            continue;
        }
        let mut labels = vec![RegionLabel::Flank(0, locus.left_flank.len())];
        let mut last_seg_end = locus.left_flank.len();
        for span in spans.split('_') {
            let (motif_index, start, end) = span
                .trim_end_matches(')')
                .split(&['(', '-'])
                .map(|s| s.parse::<usize>().unwrap())
                .collect_tuple()
                .unwrap();
            let motif = locus.motifs[motif_index].clone();
            let start = start + locus.left_flank.len();
            let end = end + locus.left_flank.len();

            if start != last_seg_end {
                labels.push(RegionLabel::Seq(last_seg_end, start));
            }
            labels.push(RegionLabel::Tr(start, end, motif));
            last_seg_end = end;
        }

        if last_seg_end != allele_len - rf_len {
            let seg_end = allele_len - rf_len;
            labels.push(RegionLabel::Seq(last_seg_end, seg_end));
            last_seg_end = seg_end;
        }

        labels.push(RegionLabel::Flank(
            last_seg_end,
            last_seg_end + locus.right_flank.len(),
        ));
        labels_by_hap.push(labels);
    }

    labels_by_hap
}

fn get_flank_labels(locus: &Locus, all_labels_by_allele: &Vec<RegionLabels>) -> Vec<RegionLabels> {
    let mut flank_labels_by_allele = Vec::new();
    for all_labels in all_labels_by_allele {
        let tr_len = all_labels
            .iter()
            .map(|l| match l {
                RegionLabel::Flank(_, _) => 0,
                RegionLabel::Other(start, end) => end - start,
                RegionLabel::Seq(start, end) => end - start,
                RegionLabel::Tr(start, end, _) => end - start,
            })
            .sum::<usize>();

        let tr_start = locus.left_flank.len();
        let tr_end = tr_start + tr_len;
        let allele_end = tr_end + locus.right_flank.len();

        flank_labels_by_allele.push(vec![
            RegionLabel::Flank(0, tr_start),
            RegionLabel::Other(tr_start, tr_end),
            RegionLabel::Flank(tr_end, allele_end),
        ]);
    }
    flank_labels_by_allele
}

fn label_with_hmm(locus: &Locus, alleles: &[String]) -> Vec<Vec<BaseLabel>> {
    let motifs = locus
        .motifs
        .iter()
        .map(|m| m.as_bytes().to_vec())
        .collect_vec();
    let hmm = build_hmm(&motifs);

    let mut labels_by_allele = Vec::new();

    for allele in alleles {
        let query = &allele[locus.left_flank.len()..allele.len() - locus.right_flank.len()];
        let mut labels = vec![BaseLabel::Match; locus.left_flank.len()];
        let states = hmm.label(query);
        labels.extend(get_base_labels(
            &locus.motifs,
            &hmm,
            &states,
            query.as_bytes(),
        ));
        labels.extend(vec![BaseLabel::Match; locus.right_flank.len()]);
        labels_by_allele.push(labels);
    }

    labels_by_allele
}

fn get_base_labels(motifs: &[String], hmm: &Hmm, states: &[usize], query: &[u8]) -> Vec<BaseLabel> {
    let motifs = motifs.iter().map(|m| m.as_bytes().to_vec()).collect_vec();
    let events = get_events(hmm, &motifs, states, query);

    let mut base_labels = Vec::new();
    for event in events {
        match event {
            HmmEvent::Match | HmmEvent::Skip => base_labels.push(BaseLabel::Match),
            HmmEvent::Ins => base_labels.push(BaseLabel::NoMatch),
            HmmEvent::Del => base_labels.push(BaseLabel::Skip),
            HmmEvent::Mismatch => base_labels.push(BaseLabel::Mismatch),
            HmmEvent::MotifStart => base_labels.push(BaseLabel::MotifBound),
            HmmEvent::Trans | HmmEvent::MotifEnd => {}
        }
    }
    base_labels.push(BaseLabel::MotifBound);
    base_labels
}
