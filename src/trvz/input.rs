use super::read::{Beta, Betas, Read};
use crate::{
    trgt::locus::create_chrom_lookup,
    trvz::locus::Locus,
    utils::{open_bam_reader, open_vcf_reader, Result},
};
use itertools::Itertools;
use rust_htslib::{
    bam::{self, record::Aux, Read as BamRead},
    bcf::{record::GenotypeAllele::UnphasedMissing, Read as BcfRead, Record},
    faidx,
};
use std::{
    collections::HashSet,
    io::{BufRead, BufReader, Read as ioRead},
    path::Path,
    str,
};

#[derive(Debug)]
pub struct Span {
    pub index: usize,
    pub start: usize,
    pub end: usize,
}

pub fn get_alleles(vcf_path: &Path, locus: &Locus) -> Result<Vec<String>> {
    let mut vcf = open_vcf_reader(vcf_path)?;
    let mut record = vcf.empty_record();

    while let Some(result) = vcf.read(&mut record) {
        result.map_err(|e| e.to_string())?;

        let tr_id = record.info(b"TRID").string().unwrap().unwrap();
        let tr_id = tr_id
            .iter()
            .map(|elem| str::from_utf8(elem).unwrap())
            .join(",");

        if tr_id != locus.id {
            continue;
        }

        let gt = record.genotypes().unwrap().get(0);
        if gt[0] == UnphasedMissing {
            return Err(format!("Missing genotype for TRID={}", tr_id));
        }

        let alleles = get_allele_seqs(locus, &record);
        return Ok(alleles);
    }
    Err(format!("TRID={} missing", &locus.id))
}

pub fn get_locus(
    catalog_reader: BufReader<Box<dyn ioRead>>,
    genome_reader: faidx::Reader,
    tr_id: &str,
    flank_len: usize,
) -> Result<Locus> {
    let chrom_lookup = create_chrom_lookup(&genome_reader)?;
    let query = format!("ID={};", tr_id);

    for (line_number, result_line) in catalog_reader.lines().enumerate() {
        let line =
            result_line.map_err(|e| format!("Error at BED line {}: {}", line_number + 1, e))?;
        if line.contains(&query) {
            return Locus::new(&genome_reader, &chrom_lookup, &line, flank_len)
                .map_err(|e| format!("Error at BED line {}: {}", line_number + 1, e));
        }
    }
    Err(format!("Unable to find locus {}", tr_id))
}

pub fn get_reads(
    bam_path: &Path,
    locus: &Locus,
    max_allele_reads: Option<usize>,
) -> Result<Vec<Read>> {
    let mut bam = open_bam_reader(bam_path, 1)?;

    // This assumes that TRGT outputs flanks shorter than 1Kbps in length. We may want
    // to implement a more flexible mechanism for handling flank lengths here and elsewhere.
    let search_radius = 1000;
    let search_start = std::cmp::max(0, locus.region.start as i64 - search_radius as i64) as u32;
    let search_end = locus.region.end + search_radius;
    let extraction_region = (locus.region.contig.as_str(), search_start, search_end);

    if let Err(e) = bam.fetch(extraction_region) {
        return Err(format!(
            "Failed to fetch region {}:{}-{} from BAM file: {}",
            locus.region.contig, search_start, search_end, e
        ));
    }

    let mut seqs = Vec::new();
    let mut read = bam::Record::new();
    while let Some(result) = bam.read(&mut read) {
        result.map_err(|e| e.to_string())?;
        let read_name = std::str::from_utf8(read.qname()).unwrap();
        let seq = str::from_utf8(&read.seq().as_bytes()).unwrap().to_string();

        let trid = match read.aux(b"TR") {
            Ok(Aux::String(value)) => value.to_string(),
            Ok(other) => {
                return Err(format!(
                    "Read '{}' has TR tag with unexpected type: {:?}",
                    read_name, other
                ));
            }
            Err(_) => {
                return Err(format!(
                    "Read '{}' is missing the TR tag. Was this BAM file generated by the latest version of TRGT?", read_name
                ));
            }
        };

        if trid != locus.id {
            continue;
        }

        let meth = parse_meth(&read, &seq)?;

        let allele = match read.aux(b"AL") {
            Ok(Aux::I32(value)) => value,
            Ok(Aux::U8(value)) => value as i32,
            Ok(other) => {
                return Err(format!(
                    "Read '{}' has AL tag with unexpected type: {:?}",
                    read_name, other
                ))
            }
            Err(_) => return Err(format!("Read '{}' is missing the AL tag", read_name)),
        };

        let (left_flank, right_flank) = match read.aux(b"FL") {
            Ok(Aux::ArrayU32(value)) => {
                if value.len() != 2 {
                    return Err(format!(
                        "Read '{}' has malformed FL tag. Expected array of 2 values, found {} values",
                        read_name,
                        value.len()
                    ));
                }
                let vals = value.iter().collect::<Vec<u32>>();
                (vals[0] as usize, vals[1] as usize)
            }
            Ok(other) => {
                return Err(format!(
                    "Read '{}' has FL tag with unexpected type: {:?}",
                    read_name, other
                ));
            }
            Err(_) => return Err(format!("Read '{}' is missing the FL tag", read_name)),
        };

        seqs.push(Read {
            seq,
            left_flank,
            right_flank,
            allele,
            betas: meth,
        });
    }

    let seqs = if let Some(max_reads) = max_allele_reads {
        let unique_alleles: Vec<i32> = seqs
            .iter()
            .map(|x| x.allele)
            .collect::<HashSet<i32>>()
            .into_iter()
            .collect();

        unique_alleles
            .into_iter()
            .map(|allele| {
                let num_allele_reads = seqs.iter().filter(|x| x.allele == allele).count();

                // GS: this only works if spanning.bam is sorted by TR length
                let step = std::cmp::max(1_usize, num_allele_reads / max_reads);
                seqs.clone()
                    .into_iter()
                    .filter(|seq| seq.allele == allele)
                    .step_by(step)
                    .take(max_reads)
                    .collect()
            })
            .concat()
    } else {
        seqs
    };

    if seqs.is_empty() {
        return Err(format!("No reads found for TRID={}", locus.id));
    }

    Ok(seqs)
}

fn get_allele_seqs(locus: &Locus, record: &Record) -> Vec<String> {
    let lf = &locus.left_flank;
    let rf = &locus.right_flank;
    let mut alleles = Vec::new();
    let genotype = record.genotypes().unwrap().get(0);
    for allele in genotype.iter() {
        let allele_index = allele.index().unwrap() as usize;
        // Remove the padding base
        let allele_seq = record.alleles()[allele_index]
            .iter()
            .skip(1)
            .copied()
            .collect_vec();
        let allele_seq = str::from_utf8(&allele_seq).unwrap();
        alleles.push(lf.clone() + allele_seq + &rf.clone());
    }
    alleles
}

fn parse_meth(read: &bam::Record, seq: &str) -> Result<Betas> {
    let values = match read.aux(b"MC") {
        Ok(Aux::ArrayU8(value)) => {
            if !value.is_empty() {
                value.iter().collect::<Vec<u8>>()
            } else {
                return Ok(Vec::new());
            }
        }
        Ok(other) => {
            let read_name = String::from_utf8(read.qname().to_vec()).unwrap();
            return Err(format!(
                "Read '{}' has MC tag with unexpected type: {:?}",
                read_name, other
            ));
        }
        Err(_) => return Ok(Vec::new()),
    };

    let mut betas = Vec::new();
    let mut cpg_count = 0;
    for pos in 0..seq.len() {
        let is_cpg = pos + 1 < seq.len() && &seq[pos..pos + 2] == "CG";
        if is_cpg {
            if cpg_count == values.len() {
                let read_name = String::from_utf8(read.qname().to_vec()).unwrap();
                return Err(format!("Read '{}' has a malformed MC tag", read_name));
            }
            let level = values[cpg_count] as f64 / 255.0;
            let beta = Beta { pos, value: level };
            betas.push(beta);
            cpg_count += 1;
        }
    }

    let all_cpgs_present = cpg_count == values.len();
    let last_cpg_split =
        seq.bytes().last().unwrap_or(b'X') == b'C' && cpg_count + 1 == values.len();

    if !(all_cpgs_present || last_cpg_split) {
        let read_name = String::from_utf8(read.qname().to_vec()).unwrap();
        return Err(format!("Read '{}' has a malformed MC tag", read_name));
    }

    Ok(betas)
}
