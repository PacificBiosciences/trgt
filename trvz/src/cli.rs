use chrono::Datelike;
use clap::Parser;
use env_logger::fmt::Color;
use lazy_static::lazy_static;
use log::{Level, LevelFilter};
use std::io::Write;
use std::path::{Path, PathBuf};

lazy_static! {
    pub static ref FULL_VERSION: String = format!(
        "{}-{}",
        env!("CARGO_PKG_VERSION"),
        env!("VERGEN_GIT_DESCRIBE")
    );
}

#[derive(Parser)]
#[command(name="trvz",
          author="Egor Dolzhenko <edolzhenko@pacificbiosciences.com>\nGuilherme De Sena Brandine <gbrandine@pacificbiosciences.com>\nTom Mokveld <tmokveld@pacificbiosciences.com>", 
          version=&**FULL_VERSION, 
          about="Tandem Repeat Visualizer", 
          long_about = None,
          after_help = format!("Copyright (C) 2004-{}     Pacific Biosciences of California, Inc.
          This program comes with ABSOLUTELY NO WARRANTY; it is intended for
          Research Use Only and not for use in diagnostic procedures.", chrono::Utc::now().year()),
          help_template = "{name} {version}\n{author}{about-section}\n{usage-heading}\n    {usage}\n\n{all-args}{after-help}",
          )]
#[command(arg_required_else_help(true))]
pub struct CliParams {
    #[clap(required = true)]
    #[clap(long = "genome")]
    #[clap(help = "Path to reference genome FASTA")]
    #[clap(value_name = "FASTA")]
    #[arg(value_parser = check_file_exists)]
    pub genome_path: PathBuf,

    #[clap(required = true)]
    #[clap(long = "repeats")]
    #[clap(help = "BED file with repeat coordinates")]
    #[clap(value_name = "REPEATS")]
    #[arg(value_parser = check_file_exists)]
    pub repeats_path: PathBuf,

    #[clap(required = true)]
    #[clap(long = "vcf")]
    #[clap(help = "VCF file generated by TRGT")]
    #[clap(value_name = "VCF")]
    #[arg(value_parser = check_file_exists)]
    pub bcf_path: PathBuf,

    #[clap(required = true)]
    #[clap(long = "spanning-reads")]
    #[clap(help = "BAM file with spanning reads generated by TRGT")]
    #[clap(value_name = "SPANNING_READS")]
    #[arg(value_parser = check_file_exists)]
    pub reads_path: PathBuf,

    #[clap(required = true)]
    #[clap(long = "repeat-id")]
    #[clap(help = "ID of the repeat to plot")]
    #[clap(value_name = "REPEAT_ID")]
    pub tr_id: String,

    #[clap(required = true)]
    #[clap(long = "image")]
    #[clap(help = "Output image path")]
    #[clap(value_name = "IMAGE")]
    #[arg(value_parser = check_prefix_path)]
    pub output_path: String,

    #[clap(long = "plot-type")]
    #[clap(value_name = "PLOT_TYPE")]
    #[clap(help = "Type of plot to generate")]
    #[clap(value_parser(["allele",  "waterfall"]))]
    #[clap(default_value = "allele")]
    pub plot_type: String,

    #[clap(long = "show")]
    #[clap(value_name = "SHOW")]
    #[clap(help = "What to show in the plot")]
    #[clap(value_parser(["motifs",  "meth"]))]
    #[clap(default_value = "motifs")]
    pub what_to_show: String,

    #[clap(long = "flank-len")]
    #[clap(value_name = "FLANK_LEN")]
    #[clap(help = "Length of flanking regions")]
    #[clap(default_value = "50")]
    pub flank_len: usize,

    #[clap(short = 'v')]
    #[clap(long = "verbose")]
    #[clap(action = clap::ArgAction::Count)]
    pub verbosity: u8,
}

fn check_args(args: CliParams) -> CliParams {
    let filter_level: LevelFilter = match args.verbosity {
        0 => LevelFilter::Warn,
        1 => LevelFilter::Info,
        _ => LevelFilter::Debug,
    };

    env_logger::Builder::from_default_env()
        .format(|buf, record| {
            let level = record.level();
            let mut style = buf.style();
            match record.level() {
                Level::Error => style.set_color(Color::Red),
                Level::Warn => style.set_color(Color::Yellow),
                Level::Info => style.set_color(Color::Green),
                Level::Debug => style.set_color(Color::Blue),
                Level::Trace => style.set_color(Color::Cyan),
            };
            writeln!(
                buf,
                "{} [{}] - {}",
                chrono::Local::now().format("%Y-%m-%d %H:%M:%S"),
                style.value(level),
                record.args()
            )
        })
        .filter_level(filter_level)
        .init();

    args
}

pub fn get_args() -> CliParams {
    let args = CliParams::parse();
    check_args(args)
}

pub fn handle_error_and_exit(err: String) -> ! {
    log::error!("{}", err);
    std::process::exit(1);
}

fn check_prefix_path(s: &str) -> Result<String, String> {
    let path = Path::new(s);
    if let Some(parent_dir) = path.parent() {
        if !parent_dir.as_os_str().is_empty() && !parent_dir.exists() {
            return Err(format!("Path does not exist: {}", parent_dir.display()));
        }
    }
    Ok(s.to_string())
}

fn check_file_exists(s: &str) -> Result<PathBuf, String> {
    let path = Path::new(s);
    if !path.exists() {
        Err(format!("File does not exist: {}", path.display()))
    } else {
        Ok(path.to_path_buf())
    }
}
